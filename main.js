/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  generateBase32Guid: () => generateBase32Guid
});
function generateBase32Guid() {
  const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
  return uuidToBase32(uuid);
}
function uuidToBase32(uuid) {
  const cleanUuid = uuid.replace(/-/g, "").toLowerCase();
  let binary = "";
  for (let i = 0; i < cleanUuid.length; i++) {
    const hex = parseInt(cleanUuid[i], 16);
    binary += hex.toString(2).padStart(4, "0");
  }
  const base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let base32 = "";
  for (let i = 0; i < binary.length; i += 5) {
    const chunk = binary.substr(i, 5).padEnd(5, "0");
    const decimal = parseInt(chunk, 2);
    base32 += base32Chars[decimal];
  }
  return base32.substring(0, 26);
}
var init_utils = __esm({
  "src/utils.ts"() {
  }
});

// src/main.ts
__export(exports, {
  default: () => ObsidianObserverPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/logger.ts
var EventLogger = class {
  constructor(app, config, pluginVersion = "unknown") {
    this.logBuffer = [];
    this.maxBufferSize = 3;
    this.app = app;
    this.config = config;
    this.pluginVersion = pluginVersion;
  }
  getPluginVersion() {
    return this.pluginVersion;
  }
  async ensureEventsDirectoryExists() {
    try {
      const eventsDir = this.config.eventsDirectory;
      const dirExists = this.app.vault.getAbstractFileByPath(eventsDir);
      if (!dirExists) {
        try {
          await this.app.vault.createFolder(eventsDir);
          console.log(`[ObsidianObserver] Created events directory: ${eventsDir}`);
          this.app.workspace.trigger("file-explorer:refresh");
        } catch (createError) {
          if (createError.message && createError.message.includes("already exists")) {
            console.log(`[ObsidianObserver] Events directory already exists: ${eventsDir}`);
          } else {
            throw createError;
          }
        }
      } else {
        console.log(`[ObsidianObserver] Events directory already exists: ${eventsDir}`);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error ensuring events directory exists:", error);
    }
  }
  async logEvent(eventLog) {
    try {
      this.logBuffer.push(eventLog);
      if (this.logBuffer.length >= this.maxBufferSize) {
        await this.flushBuffer();
      }
      if (this.config.enableConsoleLog) {
        console.log(`[ObsidianObserver] ${eventLog.eventType}: ${eventLog.filePath}`);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error logging event:", error);
    }
  }
  async flushBuffer() {
    if (this.logBuffer.length === 0)
      return;
    try {
      for (const eventLog of this.logBuffer) {
        await this.createEventNote(eventLog);
      }
      console.log(`[ObsidianObserver] Buffer flushed: ${this.logBuffer.length} event notes created`);
      this.logBuffer = [];
    } catch (error) {
      console.error("[ObsidianObserver] Error flushing log buffer:", error);
    }
  }
  async createEventNote(eventLog) {
    var _a, _b, _c, _d, _e;
    try {
      const eventsDir = this.config.eventsDirectory;
      const fileName = `${eventLog.guid}.md`;
      const filePath = `${eventsDir}/${fileName}`;
      const utcDate = new Date(eventLog.timestamp);
      const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 6e4);
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const frontmatter = {
        OOEvent_GUID: eventLog.guid,
        OOEvent_Timestamp: eventLog.timestamp,
        OOEvent_LocalTimestamp: localDate.toISOString(),
        OOEvent_Timezone: timezone,
        OOEvent_Type: eventLog.eventType,
        OOEvent_FilePath: eventLog.filePath,
        OOEvent_FileName: eventLog.fileName,
        OOEvent_VaultName: eventLog.vaultName,
        OOEvent_LastModified: ((_a = eventLog.metadata) == null ? void 0 : _a.lastModified) || "",
        OOEvent_Created: new Date().toISOString(),
        OOEvent_OldPath: (_b = eventLog.metadata) == null ? void 0 : _b.oldPath,
        OOEvent_NewPath: (_c = eventLog.metadata) == null ? void 0 : _c.newPath,
        OOEvent_SourcePath: (_d = eventLog.metadata) == null ? void 0 : _d.sourcePath,
        OOEvent_TargetPath: (_e = eventLog.metadata) == null ? void 0 : _e.targetPath,
        OOEvent_PluginVersion: this.getPluginVersion()
      };
      const noteContent = this.createNoteContent(frontmatter, eventLog);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        console.log(`[ObsidianObserver] Event note already exists: ${filePath}`);
        return;
      }
      await this.app.vault.create(filePath, noteContent);
      console.log(`[ObsidianObserver] Created event note: ${filePath}`);
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating event note:`, error);
    }
  }
  createNoteContent(frontmatter, eventLog) {
    let frontmatterFields = `---
aliases: [${eventLog.eventType.toUpperCase()} Event, ${eventLog.fileName}]
tags: [obsidian-explorer, event, ${eventLog.eventType}]
type: obsidian-event
OOEvent_GUID: ${frontmatter.OOEvent_GUID}
OOEvent_Timestamp: ${frontmatter.OOEvent_Timestamp}
OOEvent_LocalTimestamp: ${frontmatter.OOEvent_LocalTimestamp}
OOEvent_Timezone: ${frontmatter.OOEvent_Timezone}
OOEvent_Type: ${frontmatter.OOEvent_Type}
OOEvent_FilePath: ${frontmatter.OOEvent_FilePath}
OOEvent_FileName: ${frontmatter.OOEvent_FileName}
OOEvent_VaultName: ${frontmatter.OOEvent_VaultName}
OOEvent_LastModified: ${frontmatter.OOEvent_LastModified}
OOEvent_Created: ${frontmatter.OOEvent_Created}
OOEvent_PluginVersion: ${frontmatter.OOEvent_PluginVersion}`;
    if (frontmatter.OOEvent_OldPath) {
      frontmatterFields += `
OOEvent_OldPath: ${frontmatter.OOEvent_OldPath}`;
    }
    if (frontmatter.OOEvent_NewPath) {
      frontmatterFields += `
OOEvent_NewPath: ${frontmatter.OOEvent_NewPath}`;
    }
    if (frontmatter.OOEvent_SourcePath) {
      frontmatterFields += `
OOEvent_SourcePath: ${frontmatter.OOEvent_SourcePath}`;
    }
    if (frontmatter.OOEvent_TargetPath) {
      frontmatterFields += `
OOEvent_TargetPath: ${frontmatter.OOEvent_TargetPath}`;
    }
    frontmatterFields += `
---

`;
    let noteContent = frontmatterFields;
    if (eventLog.fileName && eventLog.fileName.trim() !== "") {
      noteContent += `[[${eventLog.fileName}]]`;
    } else {
      noteContent += `# ${eventLog.eventType.toUpperCase()} Event

This event was logged at ${new Date(eventLog.timestamp).toLocaleString()}.`;
    }
    return noteContent;
  }
  async createSummaryNote() {
    try {
      const summaryPath = `${this.config.eventsDirectory}/_summary.md`;
      const summaryContent = `---
aliases: [ObsidianObserver Events Summary, Events Summary]
tags: [obsidian-explorer, summary, events]
type: events-summary
version: "${this.getPluginVersion()}"
cssclasses: obsidianObserverEventsTable
---

# ObsidianObserver Events Summary

This file provides a summary of all ObsidianObserver events.

> **Note**: This summary uses the \`obsidianObserverEventsTable\` CSS class for enhanced table styling. The CSS class is automatically applied to this note.

## DataView Query Examples

### Basic Event Queries
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "open"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "save"
SORT OOEvent_LocalTimestamp DESC
LIMIT 5
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "close"
SORT OOEvent_LocalTimestamp DESC
LIMIT 5
\`\`\`

### File Management Events
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "create"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "delete"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_OldPath, OOEvent_NewPath, OOEvent_LocalTimestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_Type = "rename"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Advanced Queries
\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_Timestamp
FROM "${this.config.eventsDirectory}"
WHERE contains(OOEvent_FilePath, "Projects")
SORT OOEvent_Timestamp DESC
\`\`\`

\`\`\`dataview
TABLE OOEvent_GUID, OOEvent_Type, OOEvent_FileName, OOEvent_VaultName, OOEvent_Timestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_GUID = "ABC123DEF456GHI789JKL012"
\`\`\`

### File Size Analysis
\`\`\`dataview
TABLE OOEvent_FileName, OOEvent_FileSize, OOEvent_Type, OOEvent_Timestamp
FROM "${this.config.eventsDirectory}"
WHERE OOEvent_FileSize
SORT OOEvent_FileSize DESC
LIMIT 10
\`\`\`

### Recent Activity
\`\`\`dataview
TABLE OOEvent_FileName, OOEvent_Type, OOEvent_Timestamp
FROM "${this.config.eventsDirectory}"
SORT OOEvent_Timestamp DESC
LIMIT 20
\`\`\`

## Event Statistics

### Event Type Distribution
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "${this.config.eventsDirectory}"
GROUP BY OOEvent_Type
SORT Count DESC
\`\`\`

### Vault Activity
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "${this.config.eventsDirectory}"
GROUP BY OOEvent_VaultName
SORT Count DESC
\`\`\`

### File Activity
\`\`\`dataview
TABLE OOEvent_FileName, length(rows) as "Event Count"
FROM "${this.config.eventsDirectory}"
GROUP BY OOEvent_FileName
SORT "Event Count" DESC
LIMIT 20
\`\`\`

### Daily Activity
\`\`\`dataview
TABLE date(OOEvent_Timestamp) as "Date", length(rows) as "Events"
FROM "${this.config.eventsDirectory}"
GROUP BY date(OOEvent_Timestamp)
SORT "Date" DESC
LIMIT 30
\`\`\`
`;
      const existingFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingFile) {
        console.log(`[ObsidianObserver] Summary file already exists: ${summaryPath}`);
        return;
      }
      await this.app.vault.create(summaryPath, summaryContent);
      console.log(`[ObsidianObserver] Created summary file: ${summaryPath}`);
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating summary file:`, error);
    }
  }
  async createMainSummaryNote() {
    try {
      const summaryPath = "_debug/EventsSummary.md";
      const summaryContent = `---
aliases: [ObsidianObserver Main Summary, Events Summary]
tags: [obsidian-explorer, summary, events, main]
type: events-summary
version: "${this.getPluginVersion()}"
cssclasses: obsidianObserverEventsTable
---

# ObsidianObserver Events Summary

This file provides comprehensive DataView reports for common use-cases with ObsidianObserver events.

> **Note**: This summary uses the \`obsidianObserverEventsTable\` CSS class for enhanced table styling. The CSS class is automatically applied to this note.

## Quick Overview

### Recent Activity (Last 20 Events)
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
SORT OOEvent_LocalTimestamp DESC
LIMIT 20
\`\`\`

### Event Type Distribution
\`\`\`dataview
TABLE length(rows) as "Count"
FROM "_debug/events"
GROUP BY OOEvent_Type
SORT Count DESC
\`\`\`

### Most Active Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  length(rows) as "Total Events", 
  length(filter(rows, r => r.OOEvent_Type = "open")) as "Opens",
  length(filter(rows, r => r.OOEvent_Type = "save")) as "Saves",
  length(filter(rows, r => r.OOEvent_Type = "close")) as "Closes"
FROM "_debug/events"
GROUP BY OOEvent_FileName
SORT "Total Events" DESC
LIMIT 15
\`\`\`

## File Operations

### Recent File Opens
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "open"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recent File Saves
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "save"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recent File Closes
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "close"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

## File Management

### Recently Created Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "create"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recently Deleted Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "delete"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

### Recently Renamed Files
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  OOEvent_OldPath AS "Old Path",
  OOEvent_NewPath AS "New Path",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_Type = "rename"
SORT OOEvent_LocalTimestamp DESC
LIMIT 10
\`\`\`

## Advanced Analysis

### Project-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE contains(OOEvent_FilePath, "Projects")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

### People-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE contains(OOEvent_FilePath, "People")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

### Meeting-Related Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE contains(OOEvent_FileName, "Meeting")
SORT OOEvent_LocalTimestamp DESC
LIMIT 15
\`\`\`

## Time-Based Analysis

### Today's Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE date(OOEvent_LocalTimestamp) = date(today)
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### This Week's Activity
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE date(OOEvent_LocalTimestamp) >= date(today) - dur(7 days)
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### Daily Activity Summary (Last 30 Days)
\`\`\`dataview
TABLE date(OOEvent_LocalTimestamp) as "Date", length(rows) as "Events"
FROM "_debug/events"
GROUP BY date(OOEvent_LocalTimestamp)
SORT "Date" DESC
LIMIT 30
\`\`\`

## File Size Analysis

### Files with Size Information
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  OOEvent_FileSize AS "Size",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_FileSize
SORT OOEvent_FileSize DESC
LIMIT 10
\`\`\`

## Search and Filter

### Search by File Name
\`\`\`dataview
TABLE WITHOUT ID
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE contains(OOEvent_FileName, "YOUR_SEARCH_TERM")
SORT OOEvent_LocalTimestamp DESC
\`\`\`

### Search by GUID
\`\`\`dataview
TABLE WITHOUT ID
  OOEvent_GUID AS "GUID",
  regexreplace(OOEvent_FileName, ".md$", "") AS "File",
  upper(OOEvent_Type) AS "Type",
  dateformat(OOEvent_LocalTimestamp, "yyyy-MM-dd HH:mm:ss") AS "When"
FROM "_debug/events"
WHERE OOEvent_GUID = "YOUR_GUID_HERE"
\`\`\`

## Event Types Explained

- **open**: File opened in Obsidian editor
- **save**: File modified and saved
- **close**: File closed in editor
- **create**: New file created
- **delete**: File deleted from vault
- **rename**: File renamed or moved (includes old and new paths)
- **ready**: Obsidian application fully loaded and ready
- **quit**: Obsidian application closing

## Metadata Fields

- **OOEvent_GUID**: Unique Base32 identifier for each event
- **OOEvent_Timestamp**: ISO timestamp of the event (UTC)
- **OOEvent_LocalTimestamp**: Local timestamp of the event (user's timezone)
- **OOEvent_Type**: Type of file operation
- **OOEvent_FilePath**: Full path to the file
- **OOEvent_FileName**: Name of the file
- **OOEvent_VaultName**: Name of the vault
- **OOEvent_LastModified**: Last modification time of the file
- **OOEvent_Created**: When the event note was created
- **OOEvent_FileSize**: Size of the file in bytes
- **OOEvent_OldPath**: Previous path (for rename events)
- **OOEvent_NewPath**: New path (for rename events)
`;
      const existingFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingFile) {
        console.log(`[ObsidianObserver] Main summary file already exists: ${summaryPath}`);
        return;
      }
      await this.app.vault.create(summaryPath, summaryContent);
      console.log(`[ObsidianObserver] Created main summary file: ${summaryPath}`);
      this.app.workspace.trigger("file-explorer:refresh");
    } catch (error) {
      console.error(`[ObsidianObserver] Error creating main summary file:`, error);
    }
  }
  async refreshMainSummaryNote() {
    try {
      const summaryPath = "_debug/EventsSummary.md";
      const existingFile = this.app.vault.getAbstractFileByPath(summaryPath);
      if (existingFile) {
        await this.app.vault.delete(existingFile);
        console.log(`[ObsidianObserver] Deleted existing summary file: ${summaryPath}`);
      }
      await this.createMainSummaryNote();
      console.log(`[ObsidianObserver] Refreshed main summary file: ${summaryPath}`);
    } catch (error) {
      console.error(`[ObsidianObserver] Error refreshing main summary file:`, error);
      throw error;
    }
  }
};

// src/eventHandlers.ts
var import_obsidian = __toModule(require("obsidian"));
init_utils();
var EventHandlers = class {
  constructor(app, logger) {
    this.eventRefs = [];
    this.excludedFiles = [];
    this.isProcessingEvent = false;
    this.app = app;
    this.logger = logger;
  }
  shouldExcludeFile(filePath) {
    if (filePath.startsWith("_debug/")) {
      return true;
    }
    if (filePath.startsWith(".obsidian/")) {
      return true;
    }
    if (filePath.includes(".temp") || filePath.includes(".tmp") || filePath.includes(".cache")) {
      return true;
    }
    if (filePath.startsWith(".")) {
      return true;
    }
    return this.excludedFiles.includes(filePath);
  }
  registerEventHandlers() {
    try {
      const openRef = this.app.workspace.on("file-open", (file) => {
        if (file) {
          this.handleFileOpen(file);
        }
      });
      this.eventRefs.push(openRef);
      const saveRef = this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileSave(file);
        }
      });
      this.eventRefs.push(saveRef);
      const renameRef = this.app.vault.on("rename", (file, oldPath) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileRename(file, oldPath);
        }
      });
      this.eventRefs.push(renameRef);
      const deleteRef = this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian.TFile) {
          this.handleFileDelete(file);
        }
      });
      this.eventRefs.push(deleteRef);
      const readyRef = this.app.workspace.on("layout-ready", () => {
        this.handleAppReady();
      });
      this.eventRefs.push(readyRef);
      console.log("[ObsidianObserver] Event handlers registered successfully (open, save, rename, delete, ready)");
    } catch (error) {
      console.error("[ObsidianObserver] Error registering event handlers:", error);
    }
  }
  unregisterEventHandlers() {
    try {
      for (const eventRef of this.eventRefs) {
        this.app.workspace.offref(eventRef);
      }
      this.eventRefs = [];
      this.logger.flushBuffer();
      console.log("[ObsidianObserver] Event handlers unregistered successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error unregistering event handlers:", error);
    }
  }
  async handleFileOpen(file) {
    try {
      if (this.isProcessingEvent) {
        console.log(`[ObsidianObserver] Skipping recursive event processing for: ${file.path}`);
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        console.log(`[ObsidianObserver] Skipping excluded file: ${file.path}`);
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "open",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file open event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileSave(file) {
    try {
      if (this.isProcessingEvent) {
        console.log(`[ObsidianObserver] Skipping recursive event processing for: ${file.path}`);
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        console.log(`[ObsidianObserver] Skipping excluded file: ${file.path}`);
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "save",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file save event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileRename(file, oldPath) {
    try {
      if (this.isProcessingEvent) {
        console.log(`[ObsidianObserver] Skipping recursive event processing for: ${file.path}`);
        return;
      }
      if (this.shouldExcludeFile(file.path) || this.shouldExcludeFile(oldPath)) {
        console.log(`[ObsidianObserver] Skipping excluded file: ${file.path} (renamed from ${oldPath})`);
        return;
      }
      this.isProcessingEvent = true;
      let metadata;
      try {
        const stat = await this.app.vault.adapter.stat(file.path);
        if (stat) {
          metadata = {
            lastModified: new Date(stat.mtime).toISOString(),
            fileSize: stat.size,
            oldPath,
            newPath: file.path
          };
        }
      } catch (error) {
        console.warn("[ObsidianObserver] Error getting file metadata:", error);
      }
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "rename",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        metadata
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file rename event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleFileDelete(file) {
    try {
      if (this.isProcessingEvent) {
        console.log(`[ObsidianObserver] Skipping recursive event processing for: ${file.path}`);
        return;
      }
      if (this.shouldExcludeFile(file.path)) {
        console.log(`[ObsidianObserver] Skipping excluded file: ${file.path}`);
        return;
      }
      this.isProcessingEvent = true;
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "delete",
        filePath: file.path,
        fileName: file.name,
        vaultName: this.app.vault.getName(),
        metadata: {
          lastModified: new Date().toISOString()
        }
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling file delete event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async handleAppReady() {
    try {
      if (this.isProcessingEvent) {
        console.log("[ObsidianObserver] Skipping recursive event processing for app ready");
        return;
      }
      this.isProcessingEvent = true;
      const eventLog = {
        guid: generateBase32Guid(),
        timestamp: new Date().toISOString(),
        eventType: "ready",
        filePath: "",
        fileName: "",
        vaultName: this.app.vault.getName(),
        metadata: {
          lastModified: new Date().toISOString()
        }
      };
      await this.logger.logEvent(eventLog);
    } catch (error) {
      console.error("[ObsidianObserver] Error handling app ready event:", error);
    } finally {
      this.isProcessingEvent = false;
    }
  }
  async testLogging() {
    try {
      const testFile = this.app.workspace.getActiveFile();
      if (testFile) {
        await this.handleFileOpen(testFile);
      } else {
        const eventLog = {
          guid: generateBase32Guid(),
          timestamp: new Date().toISOString(),
          eventType: "open",
          filePath: "test-file.md",
          fileName: "test-file.md",
          vaultName: this.app.vault.getName(),
          metadata: {
            lastModified: new Date().toISOString(),
            fileSize: 1024
          }
        };
        await this.logger.logEvent(eventLog);
      }
    } catch (error) {
      console.error("[ObsidianObserver] Error in test logging:", error);
    }
  }
};

// src/main.ts
var ObsidianObserverPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("[ObsidianObserver] Loading plugin...");
    try {
      const loggerConfig = {
        eventsDirectory: "_debug/events",
        maxLogSize: 1024 * 1024,
        enableConsoleLog: true,
        includeMetadata: true
      };
      this.logger = new EventLogger(this.app, loggerConfig, this.manifest.version);
      await this.logger.ensureEventsDirectoryExists();
      await this.logger.createSummaryNote();
      await this.logger.createMainSummaryNote();
      this.eventHandlers = new EventHandlers(this.app, this.logger);
      this.eventHandlers.registerEventHandlers();
      this.addRibbonIcon("bug", "Test ObsidianObserver Logging", async () => {
        await this.eventHandlers.testLogging();
        new import_obsidian2.Notice("Test event note created!");
      });
      this.addCommand({
        id: "flush-obsidian-observer-buffer",
        name: "Flush ObsidianObserver Buffer",
        callback: async () => {
          await this.logger.flushBuffer();
          new import_obsidian2.Notice("Buffer flushed to event notes!");
        }
      });
      this.addCommand({
        id: "obsidian-observer-refresh-summary",
        name: "ObsidianObserver: Refresh Summary",
        callback: async () => {
          await this.logger.refreshMainSummaryNote();
          new import_obsidian2.Notice("Events summary refreshed!");
        }
      });
      this.addRibbonIcon("file-text", "Create Events Summary", async () => {
        await this.logger.createSummaryNote();
        new import_obsidian2.Notice("Events summary created!");
      });
      const statusBarItem = this.addStatusBarItem();
      const version = this.manifest.version;
      statusBarItem.setText(`ObsidianObserver v${version}`);
      console.log("[ObsidianObserver] Plugin loaded successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error loading plugin:", error);
    }
  }
  async onunload() {
    console.log("[ObsidianObserver] Unloading plugin...");
    try {
      if (this.logger) {
        const { generateBase32Guid: generateBase32Guid2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
        const eventLog = {
          guid: generateBase32Guid2(),
          timestamp: new Date().toISOString(),
          eventType: "quit",
          filePath: "",
          fileName: "",
          vaultName: this.app.vault.getName(),
          metadata: {
            lastModified: new Date().toISOString()
          }
        };
        await this.logger.logEvent(eventLog);
      }
      if (this.eventHandlers) {
        this.eventHandlers.unregisterEventHandlers();
      }
      if (this.logger) {
        await this.logger.flushBuffer();
      }
      console.log("[ObsidianObserver] Plugin unloaded successfully");
    } catch (error) {
      console.error("[ObsidianObserver] Error unloading plugin:", error);
    }
  }
};
